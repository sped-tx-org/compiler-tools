using System;
using System.CodeDom;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Text;
using Microsoft.CodeAnalysis.MSBuild.Writers;

namespace Microsoft.CodeAnalysis.MSBuild.Generators
{
    public class CodeGenerator
    {
        private readonly CodeWriter Output;

        private CodeTypeDeclaration CurrentType;

        private CodeTypeMember CurrentMember;

        public CodeGenerator()
        {
            Output = new CodeWriter();
        }

        public static string GenerateCodeCompileUnit(CodeCompileUnit unit)
        {
            CodeGenerator generator = new CodeGenerator();
            generator.GenerateCompileUnit(unit);
            return generator.Output.ToString();
        }

        private void GenerateCompileUnit(CodeCompileUnit unit)
        {
            Output.WriteLine("//------------------------------------------------------------------------------");
            Output.WriteLine("// <auto-generated>");
            Output.WriteLine("// This code was generated by a tool.");
            Output.WriteLine("// </auto-generated>");
            Output.WriteLine("//------------------------------------------------------------------------------");
            Output.WriteLine();

            foreach (CodeNamespaceImport import in ExtractImports(unit))
                Output.WriteUsing(import.Namespace);

            foreach (CodeNamespace ns in unit.Namespaces)
            {
                GenerateNamespace(ns);
            }
        }

        public void GenerateNamespace(CodeNamespace ns)
        {
            if (!string.IsNullOrEmpty(ns.Name))
            {
                Output.WriteLine();
                Output.WriteLine($"namespace {ns.Name}");
                Output.OpenBrace();

                foreach (CodeTypeDeclaration type in ns.Types)
                {
                    GenerateTypeDeclaration(type);
                }

                Output.CloseBrace();
            }
            else
            {
                Output.Write(string.Empty);
            }
        }

        public void GenerateTypeDeclaration(CodeTypeDeclaration ct)
        {
            CurrentType = ct;
            Output.WriteLine();
            GenerateComments(ct.Comments);
            GenerateTypeSignature(ct);
            Output.WriteLine();
            Output.OpenBrace();

            foreach (CodeTypeMember member in ct.Members)
            {
                switch (member)
                {
                    case CodeSnippetTypeMember snippetMember: GenerateCodeSnippetTypeMember(snippetMember); break;
                    case CodeMemberField codeField: GenerateFieldDeclaration(codeField); break;
                    case CodeTypeDeclaration typeDeclaration: GenerateTypeDeclaration(typeDeclaration); break;
                    case CodeMemberProperty property: GenerateProperty(property); break;
                    case CodeConstructor constructor: GenerateConstructor(constructor); break;
                    case CodeMemberMethod method: GenerateMethod(method); break;
                }

                CurrentType = ct;
            }

            Output.CloseBrace();
            CurrentType = null;
        }

        private void GenerateCodeSnippetTypeMember(CodeSnippetTypeMember e)
        {
            Output.Write(e.Text);
        }

        private void GenerateMethod(CodeMemberMethod e)
        {
            CurrentMember = e;
            Output.WriteLine();
            if (!(CurrentType.IsClass || CurrentType.IsStruct || CurrentType.IsEnum)) return;

            GenerateComments(e.Comments);

            if (!CurrentType.IsInterface)
            {
                if (e.PrivateImplementationType == null)
                {
                    OutputMemberAccessModifier(e.Attributes);
                    OutputVTableModifier(e.Attributes);
                    OutputMemberScopeModifier(e.Attributes);
                }
            }
            else
            {
                OutputVTableModifier(e.Attributes);
            }
            OutputType(e.ReturnType);
            Output.Write(" ");
            if (e.PrivateImplementationType != null)
            {
                Output.Write(GetBaseTypeOutput(e.PrivateImplementationType));
                Output.Write(".");
            }
            Output.Write(e.Name);

            OutputTypeParameters(e.TypeParameters);

            Output.Write("(");
            OutputParameters(e.Parameters);
            Output.Write(")");

            if (!CurrentType.IsInterface
                && (e.Attributes & MemberAttributes.ScopeMask) != MemberAttributes.Abstract)
            {
                Output.WriteLine();

                Output.WriteLine("{");

                Output.Indent++;
                int indent = Output.Indent;

                GenerateStatements(e.Statements);

                Output.Indent--;
                Output.WriteLine();
                Output.WriteLine("}");
            }
            else
            {
                Output.WriteLine(";");
            }

            CurrentMember = null;
        }

        private void GenerateComments(CodeCommentStatementCollection e)
        {
            foreach (CodeCommentStatement commentStatement in e)
            {
                GenerateCodeCommentStatement(commentStatement);
            }
        }

        private void GenerateCodeCommentStatement(CodeCommentStatement e)
        {
            GenerateComment(e.Comment);
        }

        private void GenerateComment(CodeComment e)
        {
            Output.Write(e.DocComment ? "/// <summary>" : "// ");
            Output.Write(e.Text);
            Output.WriteLine(e.DocComment ? "</summary>" : "");
        }

        private void GenerateStatements(CodeStatementCollection e)
        {
            foreach (CodeStatement statement in e)
            {
                GenerateStatement(statement);
            }
        }

        private void OutputParameters(CodeParameterDeclarationExpressionCollection parameters)
        {
            bool first = true;
            bool multiline = parameters.Count > 16;
            if (multiline)
            {
                Output.Indent += 3;
            }
            IEnumerator en = parameters.GetEnumerator();
            while (en.MoveNext())
            {
                CodeParameterDeclarationExpression current = (CodeParameterDeclarationExpression)en.Current;
                if (first)
                {
                    first = false;
                }
                else
                {
                    Output.Write(", ");
                }
                if (multiline)
                {
                    Output.WriteLine();
                }
                bool isParams = GetUserDataValue<bool>(current.UserData, "IsParams");
                if (isParams)
                {
                    Output.Write("params ");
                    current.Type = new CodeTypeReference($"{current.Type.BaseType}[]");
                }
                GenerateExpression(current);
            }
            if (multiline)
            {
                Output.Indent -= 3;
            }
        }

        private void OutputTypeParameters(CodeTypeParameterCollection typeParameters)
        {
            if (typeParameters.Count == 0)
            {
                return;
            }

            Output.Write('<');
            bool first = true;
            for (int i = 0; i < typeParameters.Count; i++)
            {
                if (first)
                {
                    first = false;
                }
                else
                {
                    Output.Write(", ");
                }

                if (typeParameters[i].CustomAttributes.Count > 0)
                {
                    GenerateAttributes(typeParameters[i].CustomAttributes, null, true);
                    Output.Write(' ');
                }

                Output.Write(typeParameters[i].Name);
            }

            Output.Write('>');
        }

        private void GenerateAttributeDeclarationsStart(CodeAttributeDeclarationCollection attributes)
        {
            Output.Write("[");
        }

        private void GenerateAttributeDeclarationsEnd(CodeAttributeDeclarationCollection attributes)
        {
            Output.Write("]");
        }

        private void GenerateAttributes(CodeAttributeDeclarationCollection attributes, string prefix, bool inLine)
        {
            if (attributes.Count == 0) return;
            IEnumerator en = attributes.GetEnumerator();
            bool paramArray = false;

            while (en.MoveNext())
            {
                CodeAttributeDeclaration current = (CodeAttributeDeclaration)en.Current;

                if (current.Name.Equals("system.paramarrayattribute", StringComparison.OrdinalIgnoreCase))
                {
                    paramArray = true;
                    continue;
                }

                GenerateAttributeDeclarationsStart(attributes);
                if (prefix != null)
                {
                    Output.Write(prefix);
                }

                if (current.AttributeType != null)
                {
                    Output.Write(GetTypeOutput(current.AttributeType));
                }
                Output.Write("(");

                bool firstArg = true;
                foreach (CodeAttributeArgument arg in current.Arguments)
                {
                    if (firstArg)
                    {
                        firstArg = false;
                    }
                    else
                    {
                        Output.Write(", ");
                    }

                    OutputAttributeArgument(arg);
                }

                Output.Write(")");
                GenerateAttributeDeclarationsEnd(attributes);
                if (inLine)
                {
                    Output.Write(" ");
                }
                else
                {
                    Output.WriteLine();
                }
            }

            if (paramArray)
            {
                if (prefix != null)
                {
                    Output.Write(prefix);
                }
                Output.Write("params");

                if (inLine)
                {
                    Output.Write(" ");
                }
                else
                {
                    Output.WriteLine();
                }
            }
        }

        private void OutputAttributeArgument(CodeAttributeArgument arg)
        {
            if (!string.IsNullOrEmpty(arg.Name))
            {
                Output.Write(arg.Name);
                Output.Write("=");
            }
            GenerateExpression(arg.Value);
        }

        private void GenerateFieldDeclaration(CodeMemberField e)
        {
            CurrentMember = e;
            //if (!(CurrentType.IsClass || CurrentType.IsStruct || CurrentType.IsEnum)) return;

            //CurrentMember = null;

            if ((CurrentType is CodeTypeDelegate) || CurrentType.IsInterface) return;

            if (CurrentType.IsEnum)
            {
                if (e.CustomAttributes.Count > 0)
                {
                    GenerateAttributes(e.CustomAttributes);
                }
                Output.Write(e.Name);
                if (e.InitExpression != null)
                {
                    Output.Write(" = ");
                    GenerateExpression(e.InitExpression);
                }
                Output.WriteLine(",");
            }
            else
            {
                if (e.CustomAttributes.Count > 0)
                {
                    GenerateAttributes(e.CustomAttributes);
                }
                OutputAccessibilityAndModifiers(e.Attributes);

                if (GetUserDataValue<bool>(e.UserData, "ReadOnly"))
                {
                    Output.Write("readonly ");
                }

                OutputType(e.Type);
                Output.Write(' ');
                Output.Write(e.Name);
                Output.WriteLine(';');
            }

            CurrentMember = null;
        }

        private void GenerateAttributes(CodeAttributeDeclarationCollection attributes)
        {
            GenerateAttributes(attributes, null, false);
        }

        private void GenerateAttributes(CodeAttributeDeclarationCollection attributes, string prefix)
        {
            GenerateAttributes(attributes, prefix, false);
        }

        private T GetUserDataValue<T>(IDictionary dictionary, string key)
        {
            if (dictionary.Contains(key))
            {
                return (T)dictionary[key];
            }

            return default(T);
        }

        private void GenerateConstructor(CodeConstructor e)
        {
            if (!(CurrentType.IsClass || CurrentType.IsStruct)) return;

            CurrentMember = e;

            Output.WriteLine();
            OutputAccessibilityAndModifiers(e.Attributes);
            Output.Write(e.Name);
            Output.OpenParen(false);
            GenerateParameters(e.Parameters);
            Output.WriteLine(')');
            Output.PushIndent();

            CodeExpressionCollection baseArgs = e.BaseConstructorArgs;
            CodeExpressionCollection thisArgs = e.ChainedConstructorArgs;

            if (baseArgs.Count > 0)
            {
                Output.Write(" : ");
                Output.PushIndent();
                Output.PushIndent();
                Output.Write("base(");
                GenerateExpressionList(baseArgs, false);
                Output.Write(")");
                Output.PopIndent();
                Output.PopIndent();
            }

            if (thisArgs.Count > 0)
            {
                Output.WriteLine(" : ");
                Output.PushIndent();
                Output.PushIndent();
                Output.Write("this(");
                GenerateExpressionList(thisArgs, false);
                Output.Write(")");
                Output.PopIndent();
                Output.PopIndent();
            }
            Output.PopIndent();
            Output.WriteLine();
            Output.OpenBrace();
            GenerateStatements(e.Statements);
            Output.CloseBrace();

            CurrentMember = null;
        }

        private void GenerateExpressionList(CodeExpressionCollection expressions, bool newlineBetweenItems)
        {
            bool first = true;
            IEnumerator en = expressions.GetEnumerator();
            Output.PushIndent();
            while (en.MoveNext())
            {
                if (first)
                {
                    first = false;
                }
                else if (newlineBetweenItems)
                    Output.WriteLine(',');
                else
                    Output.Write(", ");
                GenerateExpression((CodeExpression)en.Current);
            }
            Output.PopIndent();
        }

        private void GenerateExpression(CodeExpression e)
        {
            switch (e)
            {
                case CodeParameterDeclarationExpression parameterDeclarationExpression:
                    GenerateParameterDeclarationExpression(parameterDeclarationExpression);
                    break;
                case CodeMethodReferenceExpression methodReferenceExpression:
                    GenerateCodeMethodReferenceExpression(methodReferenceExpression);
                    break;
                case CodeThisReferenceExpression thisReferenceExpression:
                    GenerateCodeThisReferenceExpression(thisReferenceExpression);
                    break;
                case CodePropertyReferenceExpression propertyReference:
                    GenerateCodePropertyReferenceExpression(propertyReference);
                    break;
                case CodeCastExpression castExpression:
                    GenerateCodeCastExpression(castExpression);
                    break;
                case CodeObjectCreateExpression objectCreateExpression:
                    GenerateObjectCreateExpression(objectCreateExpression);
                    break;
                case CodePrimitiveExpression primativeExpression:
                    GeneratePrimitiveExpression(primativeExpression);
                    break;
                case CodeMethodInvokeExpression invokeExpression:
                    GenerateCodeMethodInvokeExpression(invokeExpression);
                    break;
                case CodeVariableReferenceExpression variableReference:
                    GenerateCodeVariableReferenceExpression(variableReference);
                    break;
                case CodeBinaryOperatorExpression binaryOperator:
                    GenerateCodeBinaryOperatorExpression(binaryOperator);
                    break;
                case CodeDefaultValueExpression defaultValue:
                    GenerateCodeDefaultValueExpression(defaultValue);
                    break;
                case CodeArrayCreateExpression arrayCreateExpression:
                    GenerateCodeArrayCreateExpression(arrayCreateExpression);
                    break;
                case CodeTypeOfExpression typeofExpression:
                    GenerateCodeTypeOfExpression(typeofExpression);
                    break;
                case CodeArgumentReferenceExpression argumentReference:
                    GenerateCodeArgumentReferenceExpression(argumentReference);
                    break;
                case CodeSwitchSectionLabelExpression switchSectionLabel:
                    GenerateCodeSwitchSectionLabelExpression(switchSectionLabel);
                    break;
            }
        }

        private void GenerateCodeSwitchSectionLabelExpression(CodeSwitchSectionLabelExpression e)
        {
            Output.Write("case ");
            GenerateExpression(e.Expression);
            Output.Write(": ");
        }

        private void GenerateCodeVariableReferenceExpression(CodeVariableReferenceExpression e)
        {
            GenerateIdentifier(e.VariableName);
        }

        private void GenerateCodeArgumentReferenceExpression(CodeArgumentReferenceExpression e)
        {
            GenerateIdentifier(e.ParameterName);
        }

        private void GenerateCodeTypeOfExpression(CodeTypeOfExpression e)
        {
            Output.Write("typeof(");
            OutputType(e.Type);
            Output.Write(")");
        }

        private void GenerateCodeArrayCreateExpression(CodeArrayCreateExpression e)
        {
            Output.Write("new ");

            CodeExpressionCollection init = e.Initializers;
            if (init.Count > 0)
            {
                OutputType(e.CreateType);
                if (e.CreateType.ArrayRank == 0)
                {
                    Output.Write("[]");
                }
                Output.WriteLine();
                Output.WriteLine("{");
                OutputExpressionList(init, true);
                Output.WriteLine();
                Output.Write("}");
            }
            else
            {
                Output.Write(GetBaseTypeOutput(e.CreateType));

                Output.Write("[");
                if (e.SizeExpression != null)
                {
                    GenerateExpression(e.SizeExpression);
                }
                else
                {
                    Output.Write(e.Size);
                }
                Output.Write("]");
            }
        }

        private void OutputExpressionList(CodeExpressionCollection expressions, bool newlineBetweenItems)
        {
            bool first = true;
            IEnumerator en = expressions.GetEnumerator();
            Output.Indent++;
            while (en.MoveNext())
            {
                if (first)
                {
                    first = false;
                }
                else if (newlineBetweenItems)
                    Output.WriteLine(",");
                else
                    Output.Write(", ");
                GenerateExpression((CodeExpression)en.Current);
            }
            Output.Indent--;
        }

        private void GenerateCodeDefaultValueExpression(CodeDefaultValueExpression e)
        {
            Output.Write("default(");
            OutputType(e.Type);
            Output.Write(")");
        }

        private void GenerateCodeMethodReferenceExpression(CodeMethodReferenceExpression e)
        {
            if (e.TargetObject != null)
            {
                if (e.TargetObject is CodeVariableReferenceExpression variableReference)
                {
                    GenerateCodeVariableReferenceExpression(variableReference);
                }
                else if (e.TargetObject is CodeBinaryOperatorExpression binaryExpression)
                {
                    Output.Write("(");
                    GenerateExpression(binaryExpression);
                    Output.Write(")");
                }
                else
                {
                    GenerateExpression(e.TargetObject);
                    if (!(e.TargetObject is CodeThisReferenceExpression))
                    {
                        if (CurrentMember.Name == "Grammar")
                        {
                        }
                    }
                }
                Output.Write(".");
            }
            Output.Write(e.MethodName);

            if (e.TypeArguments.Count > 0)
            {
                Output.Write(GetTypeArgumentsOutput(e.TypeArguments));
            }
        }

        private String GetTypeArgumentsOutput(CodeTypeReferenceCollection typeArguments)
        {
            StringBuilder sb = new StringBuilder(128);
            GetTypeArgumentsOutput(typeArguments, 0, typeArguments.Count, sb);
            return sb.ToString();
        }

        private void GetTypeArgumentsOutput(CodeTypeReferenceCollection typeArguments, int start, int length, StringBuilder sb)
        {
            sb.Append('<');
            bool first = true;
            for (int i = start; i < start + length; i++)
            {
                if (first)
                {
                    first = false;
                }
                else
                {
                    sb.Append(", ");
                }
                if (i < typeArguments.Count)
                    sb.Append(GetTypeOutput(typeArguments[i]));
            }
            sb.Append('>');
        }

        private void GenerateCodeThisReferenceExpression(CodeThisReferenceExpression e)
        {
            Output.Write("this");
        }

        private void GenerateCodeCastExpression(CodeCastExpression e)
        {
            Output.Write("((");
            OutputType(e.TargetType);
            if (e.Expression is CodeVariableReferenceExpression)
            {
                Output.Write(")");
                GenerateExpression(e.Expression);
                Output.Write(")");
            }
            else
            {
                Output.Write(")(");
                GenerateExpression(e.Expression);
                Output.Write("))");
            }
        }

        private void GenerateCodePropertyReferenceExpression(CodePropertyReferenceExpression e)
        {
            if (e.TargetObject != null)
            {
                GenerateExpression(e.TargetObject);
                Output.Write(".");
            }
            Output.Write(e.PropertyName);
        }

        private void GenerateObjectCreateExpression(CodeObjectCreateExpression e)
        {
            Output.Write("new ");
            OutputType(e.CreateType);
            Output.OpenParen(false);
            GenerateParameters(e.Parameters);
            Output.CloseParen(false);
        }

        private void GeneratePrimitiveExpression(CodePrimitiveExpression e)
        {
            if (e.Value is string str)
            {
                Output.Write('"');
                Output.Write(str);
                Output.Write('"');
            }
            else if (e.Value is bool b)
            {
                if (b)
                {
                    Output.Write("true");
                }
                else
                {
                    Output.Write("false");
                }
            }
            else
            {
                Output.Write(e.Value);
            }
        }

        private void GenerateCodeMethodInvokeExpression(CodeMethodInvokeExpression e)
        {
            GenerateCodeMethodReferenceExpression(e.Method);
            Output.OpenParen(false);
            OutputExpressionList(e.Parameters, false);
            Output.CloseParen(false);
        }

        private void GenerateProperty(CodeMemberProperty e)
        {
            CurrentMember = e;

            Output.WriteLine();

            if (!CurrentType.IsInterface)
            {
                OutputAccessibilityAndModifiers(e.Attributes);
            }
            OutputType(e.Type);
            Output.Write(" ");
            Output.Write(e.Name);

            if (e.GetStatements.Count == 0)
            {
                if (e.HasGet && !e.HasSet)
                {
                    Output.WriteLine(" { get; }");
                }
                else if (e.GetStatements.Count == 0 && e.SetStatements.Count == 0)
                    Output.WriteLine(" { get; set; }");
            }
            else
            {
                Output.WriteLine();
                Output.OpenBrace();
                Output.WriteLine("get");
                Output.OpenBrace();
                foreach (CodeStatement statement in e.GetStatements)
                {
                    GenerateStatement(statement);
                }
                Output.CloseBrace();
                Output.CloseBrace();
            }
            CurrentMember = null;
        }

        private void GenerateStatement(CodeStatement statement)
        {
            switch (statement)
            {
                case CodeSnippetStatement snippetStatement:
                    GenerateCodeSnippetStatement(snippetStatement);
                    break;
                case CodeMethodReturnStatement returnstatement:
                    GenerateCodeMethodReturnStatement(returnstatement);
                    break;
                case CodeExpressionStatement expressionStatement:
                    GenerateCodeExpressionStatement(expressionStatement);
                    break;
                case CodeConditionStatement conditionStatement:
                    GenerateCodeConditionStatement(conditionStatement);
                    break;
                case CodeVariableDeclarationStatement variableStatement:
                    GenerateCodeVariableDeclarationStatement(variableStatement);
                    break;
                case CodeAssignStatement assignStatement:
                    GenerateCodeAssignStatement(assignStatement);
                    break;
                case CodeThrowExceptionStatement exceptionStatement:
                    GenerateCodeThrowExceptionStatement(exceptionStatement);
                    break;
                case CodeSwitchStatement switchStatement:
                    GenerateCodeSwitchStatement(switchStatement);
                    break;
            }
        }

        private void GenerateCodeSwitchStatement(CodeSwitchStatement e)
        {
            Output.Write("switch(");
            GenerateExpression(e.CheckExpression);
            Output.WriteLine(")");
            Output.WriteLine("{");
            Output.Indent++;
            GenerateSwitchSections(e.Sections);
            Output.Indent--;
            Output.WriteLine("}");
        }

        private void GenerateSwitchSections(CodeSwitchSectionStatementCollection e)
        {
            foreach (var section in e)
            {
                switch (section)
                {
                    case CodeReturnValueSwitchSectionStatement returnValueSection:
                        GenerateCodeReturnValueSwitchSectionStatement(returnValueSection);
                        break;
                    case CodeBreakSwitchSectionStatement breakSection:
                        GenerateCodeBreakSwitchSectionStatement(breakSection);
                        break;
                    case CodeFallThroughSwitchSectionStatement fallThroughSection:
                        GenerateCodeFallThroughSwitchSectionStatement(fallThroughSection);
                        break;
                    case CodeDefaultBreakSwitchSectionStatement defaultBreakSection:
                        GenerateCodeDefaultBreakSwitchSectionStatement(defaultBreakSection);
                        break;
                    case CodeDefaultReturnSwitchSectionStatement defaultReturnSection:
                        GenerateCodeDefaultReturnSwitchSectionStatement(defaultReturnSection);
                        break;
                }
            }
        }

        private void GenerateCodeDefaultReturnSwitchSectionStatement(CodeDefaultReturnSwitchSectionStatement e)
        {
            Output.WriteLine("default:");
            Output.WriteLine("{");
            Output.Indent++;
            if (e.BodyStatements.Count > 0)
            {
                GenerateStatements(e.BodyStatements);
            }
            GenerateCodeMethodReturnStatement(e.ReturnStatement);
            Output.Indent--;
            Output.WriteLine("}");
        }

        private void GenerateCodeDefaultBreakSwitchSectionStatement(CodeDefaultBreakSwitchSectionStatement e)
        {
            Output.WriteLine("default:");
            Output.WriteLine("{");
            Output.Indent++;
            if (e.BodyStatements.Count > 0)
            {
                GenerateStatements(e.BodyStatements);
            }
            Output.WriteLine("break;");
            Output.Indent--;
            Output.WriteLine("}");
        }

        private void GenerateCodeFallThroughSwitchSectionStatement(CodeFallThroughSwitchSectionStatement e)
        {
            GenerateCodeSwitchSectionLabelExpression(e.Label);
            Output.WriteLine();
        }

        private void GenerateCodeBreakSwitchSectionStatement(CodeBreakSwitchSectionStatement e)
        {
            GenerateCodeSwitchSectionLabelExpression(e.Label);
            Output.WriteLine();
            Output.WriteLine("{");
            Output.Indent++;
            if (e.BodyStatements.Count > 0)
            {
                GenerateStatements(e.BodyStatements);
            }
            Output.WriteLine("break;");
            Output.Indent--;
            Output.WriteLine("}");
        }

        private void GenerateCodeReturnValueSwitchSectionStatement(CodeReturnValueSwitchSectionStatement e)
        {
            GenerateCodeSwitchSectionLabelExpression(e.Label);
            if (e.SingleLine)
            {
                GenerateCodeMethodReturnStatement(e.ReturnStatement);
            }
            else
            {
                Output.WriteLine();
                Output.WriteLine("{");
                Output.Indent++;
                if (e.BodyStatements.Count > 0)
                {
                    GenerateStatements(e.BodyStatements);
                }
                GenerateCodeMethodReturnStatement(e.ReturnStatement);
                Output.Indent--;
                Output.WriteLine("}");
            }
        }


        private void GenerateCodeThrowExceptionStatement(CodeThrowExceptionStatement e)
        {
            Output.Write("throw");
            if (e.ToThrow != null)
            {
                Output.Write(" ");
                GenerateExpression(e.ToThrow);
            }
            Output.WriteLine(";");
        }

        private void GenerateCodeAssignStatement(CodeAssignStatement e)
        {
            GenerateExpression(e.Left);
            Output.Write(" = ");
            GenerateExpression(e.Right);
            Output.WriteLine(";");
        }

        private void GenerateCodeVariableDeclarationStatement(CodeVariableDeclarationStatement e)
        {
            GenerateTypeNamePair(e.Type, e.Name);
            if (e.InitExpression != null)
            {
                Output.Write(" = ");
                GenerateExpression(e.InitExpression);
            }
            Output.WriteLine(";");
        }


        private bool inNestedBinary;

        private void GenerateCodeBinaryOperatorExpression(CodeBinaryOperatorExpression e)
        {
            bool indentedExpression = false;
            Output.Write("(");

            GenerateExpression(e.Left);
            Output.Write(" ");

            if (e.Left is CodeBinaryOperatorExpression || e.Right is CodeBinaryOperatorExpression)
            {
                if (!inNestedBinary)
                {
                    indentedExpression = true;
                    inNestedBinary = true;
                    Output.Indent += 3;
                }
                Output.WriteLine();
            }

            OutputOperator(e.Operator);

            Output.Write(" ");
            GenerateExpression(e.Right);

            Output.Write(")");
            if (indentedExpression)
            {
                Output.Indent -= 3;
                inNestedBinary = false;
            }
        }

        private void OutputOperator(CodeBinaryOperatorType op)
        {
            switch (op)
            {
                case CodeBinaryOperatorType.Add:
                    Output.Write("+");
                    break;
                case CodeBinaryOperatorType.Subtract:
                    Output.Write("-");
                    break;
                case CodeBinaryOperatorType.Multiply:
                    Output.Write("*");
                    break;
                case CodeBinaryOperatorType.Divide:
                    Output.Write("/");
                    break;
                case CodeBinaryOperatorType.Modulus:
                    Output.Write("%");
                    break;
                case CodeBinaryOperatorType.Assign:
                    Output.Write("=");
                    break;
                case CodeBinaryOperatorType.IdentityInequality:
                    Output.Write("!=");
                    break;
                case CodeBinaryOperatorType.IdentityEquality:
                    Output.Write("==");
                    break;
                case CodeBinaryOperatorType.ValueEquality:
                    Output.Write("==");
                    break;
                case CodeBinaryOperatorType.BitwiseOr:
                    Output.Write("|");
                    break;
                case CodeBinaryOperatorType.BitwiseAnd:
                    Output.Write("&");
                    break;
                case CodeBinaryOperatorType.BooleanOr:
                    Output.Write("||");
                    break;
                case CodeBinaryOperatorType.BooleanAnd:
                    Output.Write("&&");
                    break;
                case CodeBinaryOperatorType.LessThan:
                    Output.Write("<");
                    break;
                case CodeBinaryOperatorType.LessThanOrEqual:
                    Output.Write("<=");
                    break;
                case CodeBinaryOperatorType.GreaterThan:
                    Output.Write(">");
                    break;
                case CodeBinaryOperatorType.GreaterThanOrEqual:
                    Output.Write(">=");
                    break;
            }
        }

        private void GenerateCodeConditionStatement(CodeConditionStatement e)
        {
            Output.Write("if (");
            GenerateExpression(e.Condition);
            Output.WriteLine(")");
            Output.WriteLine("{");
            Output.Indent++;
            GenerateStatements(e.TrueStatements);
            Output.Indent--;

            CodeStatementCollection falseStatemetns = e.FalseStatements;
            if (falseStatemetns.Count > 0)
            {
                Output.Write("}");
                Output.WriteLine("else");
                Output.WriteLine("{");
                Output.Indent++;
                GenerateStatements(e.FalseStatements);
                Output.Indent--;
            }
            Output.WriteLine("}");
        }

        private void GenerateCodeExpressionStatement(CodeExpressionStatement e)
        {
            GenerateExpression(e.Expression);
            Output.WriteLine(";");
        }

        private void GenerateCodeSnippetStatement(CodeSnippetStatement e)
        {
            Output.Write(e.Value);
        }

        private void GenerateCodeMethodReturnStatement(CodeMethodReturnStatement e)
        {
            Output.Write("return ");
            GenerateExpression(e.Expression);
            Output.WriteLine(';');
        }

        private void OutputAccessibilityAndModifiers(MemberAttributes attributes)
        {
            OutputMemberAccessModifier(attributes);
            OutputVTableModifier(attributes);
            OutputMemberScopeModifier(attributes);
        }

        private void OutputVTableModifier(MemberAttributes attributes)
        {
            switch (attributes
                & MemberAttributes.VTableMask)
            {
                case MemberAttributes.New:
                    Output.Write("new ");
                    break;
            }
        }

        private void OutputMemberAccessModifier(MemberAttributes attributes)
        {
            switch (attributes & MemberAttributes.AccessMask)
            {
                case MemberAttributes.Assembly:
                    Output.Write("internal ");
                    break;
                case MemberAttributes.FamilyAndAssembly:
                    Output.Write("internal ");
                    break;
                case MemberAttributes.Family:
                    Output.Write("protected ");
                    break;
                case MemberAttributes.FamilyOrAssembly:
                    Output.Write("protected internal ");
                    break;
                case MemberAttributes.Private:
                    Output.Write("private ");
                    break;
                case MemberAttributes.Public:
                    Output.Write("public ");
                    break;
            }

            if (GetUserDataValue<bool>(CurrentMember.UserData, "IsVirtual"))
            {
                Output.Write("virtual ");
            }
        }

        private void OutputMemberScopeModifier(MemberAttributes attributes)
        {
            switch (attributes & MemberAttributes.ScopeMask)
            {
                case MemberAttributes.Abstract:
                    Output.Write("abstract ");
                    break;
                case MemberAttributes.Final:
                    Output.Write("sealed ");
                    break;
                case MemberAttributes.Static:
                    Output.Write("static ");
                    break;
                case MemberAttributes.Override:
                    Output.Write("override ");
                    break;
            }
        }

        private void GenerateTypeSignature(CodeTypeDeclaration e)
        {
            TypeAttributes attributes = e.TypeAttributes;
            switch (attributes & TypeAttributes.VisibilityMask)
            {
                case TypeAttributes.Public:
                case TypeAttributes.NestedPublic:
                    Output.Write("public ");
                    break;
                case TypeAttributes.NestedPrivate:
                    Output.Write("private ");
                    break;
                case TypeAttributes.NestedFamily:
                    Output.Write("protected ");
                    break;
                case TypeAttributes.NotPublic:
                case TypeAttributes.NestedAssembly:
                case TypeAttributes.NestedFamANDAssem:
                    Output.Write("internal ");
                    break;
                case TypeAttributes.NestedFamORAssem:
                    Output.Write("protected internal ");
                    break;
            }

            if (e.Attributes.HasFlag(MemberAttributes.Static))
            {
                Output.Write("static ");
            }

            if (e.IsStruct)
            {
                if (e.IsPartial)
                {
                    Output.Write("partial ");
                }
                Output.Write("struct ");
            }
            else if (e.IsEnum)
            {
                Output.Write("enum ");
            }
            else
            {
                switch (attributes & TypeAttributes.ClassSemanticsMask)
                {
                    case TypeAttributes.Class:
                        if ((attributes & TypeAttributes.Sealed) == TypeAttributes.Sealed)
                        {
                            Output.Write("sealed ");
                        }
                        if ((attributes & TypeAttributes.Abstract) == TypeAttributes.Abstract)
                        {
                            Output.Write("abstract ");
                        }
                        if (e.IsPartial)
                        {
                            Output.Write("partial ");
                        }

                        Output.Write("class ");

                        break;
                    case TypeAttributes.Interface:
                        if (e.IsPartial)
                        {
                            Output.Write("partial ");
                        }
                        Output.Write("interface ");
                        break;
                }
            }

            Output.Write($"{e.Name}");

            if (e.TypeParameters.Count > 0)
                GenerateTypeParameters(e.TypeParameters);

            bool first = true;
            foreach (CodeTypeReference typeRef in e.BaseTypes)
            {
                if (first)
                {
                    Output.Write(" : ");
                    first = false;
                }
                else
                {
                    Output.Write(", ");
                }
                OutputType(typeRef);
            }

            GenerateTypeParameterConstraints(e.TypeParameters);
        }

        private void GenerateTypeParameters(CodeTypeParameterCollection tp)
        {
            if (tp.Count == 0)
            {
                return;
            }

            Output.Write('<');
            bool first = true;
            for (int i = 0; i < tp.Count; i++)
            {
                if (first)
                {
                    first = false;
                }
                else
                {
                    Output.Write(", ");
                }

                Output.Write(tp[i].Name);
            }

            Output.Write('>');
        }

        private void GenerateTypeParameterConstraints(CodeTypeParameterCollection typeParameters)
        {
            if (typeParameters.Count == 0)
            {
                return;
            }

            for (int i = 0; i < typeParameters.Count; i++)
            {
                Output.WriteLine();
                Output.PushIndent();

                bool first = true;
                if (typeParameters[i].Constraints.Count > 0)
                {
                    foreach (CodeTypeReference typeRef in typeParameters[i].Constraints)
                    {
                        if (first)
                        {
                            Output.Write("where ");
                            Output.Write(typeParameters[i].Name);
                            Output.Write(": ");
                            first = false;
                        }
                        else
                        {
                            Output.Write(", ");
                        }
                        Output.Write(GetTypeOutput(typeRef));
                    }
                }

                if (typeParameters[i].HasConstructorConstraint)
                {
                    if (first)
                    {
                        Output.Write("where ");
                        Output.Write(typeParameters[i].Name);
                        Output.Write(" : new()");
                    }
                    else
                    {
                        Output.Write(", new ()");
                    }
                }

                Output.PopIndent();
            }
        }

        private bool IsKeyword(string text)
        {
            switch (text)
            {
                case "abstract":
                case "as":
                case "base":
                case "bool":
                case "break":
                case "byte":
                case "case":
                case "catch":
                case "char":
                case "checked":
                case "class":
                case "const":
                case "continue":
                case "decimal":
                case "default":
                case "delegate":
                case "do":
                case "double":
                case "else":
                case "enum":
                case "event":
                case "explicit":
                case "extern":
                case "false":
                case "finally":
                case "fixed":
                case "float":
                case "for":
                case "foreach":
                case "goto":
                case "if":
                case "implicit":
                case "in":
                case "int":
                case "interface":
                case "internal":
                case "is":
                case "lock":
                case "long":
                case "namespace":
                case "new":
                case "null":
                case "object":
                case "operator":
                case "out":
                case "override":
                case "params":
                case "private":
                case "protected":
                case "public":
                case "readonly":
                case "ref":
                case "return":
                case "sbyte":
                case "sealed":
                case "short":
                case "sizeof":
                case "stackalloc":
                case "static":
                case "string":
                case "struct":
                case "switch":
                case "this":
                case "throw":
                case "true":
                case "try":
                case "typeof":
                case "uint":
                case "ulong":
                case "unchecked":
                case "unsafe":
                case "ushort":
                case "using":
                case "virtual":
                case "void":
                case "volatile":
                case "while":
                    return true;
                default:
                    return false;
            }
        }

        private void OutputType(CodeTypeReference e)
        {
            Output.Write(GetTypeOutput(e));
        }

        private string GetTypeOutput(CodeTypeReference typeRef)
        {
            string s = String.Empty;

            CodeTypeReference baseTypeRef = typeRef;
            while (baseTypeRef.ArrayElementType != null)
            {
                baseTypeRef = baseTypeRef.ArrayElementType;
            }
            s += GetBaseTypeOutput(baseTypeRef);

            while (typeRef != null && typeRef.ArrayRank > 0)
            {
                char[] results = new char[typeRef.ArrayRank + 1];
                results[0] = '[';
                results[typeRef.ArrayRank] = ']';
                for (int i = 1; i < typeRef.ArrayRank; i++)
                {
                    results[i] = ',';
                }
                s += new string(results);
                typeRef = typeRef.ArrayElementType;
            }

            return s;
        }

        private string GetBaseTypeOutput(CodeTypeReference typeRef)
        {
            string s = typeRef.BaseType;
            if (s.Length == 0)
            {
                s = "void";
                return s;
            }

            string lowerCaseString = s.ToLower(CultureInfo.InvariantCulture).Trim();

            switch (lowerCaseString)
            {
                case "system.int16":
                    s = "short";
                    break;
                case "system.int32":
                    s = "int";
                    break;
                case "system.int64":
                    s = "long";
                    break;
                case "system.string":
                    s = "string";
                    break;
                case "system.object":
                    s = "object";
                    break;
                case "system.boolean":
                    s = "bool";
                    break;
                case "system.void":
                    s = "void";
                    break;
                case "system.char":
                    s = "char";
                    break;
                case "system.byte":
                    s = "byte";
                    break;
                case "system.uint16":
                    s = "ushort";
                    break;
                case "system.uint32":
                    s = "uint";
                    break;
                case "system.uint64":
                    s = "ulong";
                    break;
                case "system.sbyte":
                    s = "sbyte";
                    break;
                case "system.single":
                    s = "float";
                    break;
                case "system.double":
                    s = "double";
                    break;
                case "system.decimal":
                    s = "decimal";
                    break;
            }
            return s;
        }

        private List<CodeNamespaceImport> ExtractImports(CodeCompileUnit unit)
        {
            List<CodeNamespaceImport> list = new List<CodeNamespaceImport>();

            foreach (CodeNamespace ns in unit.Namespaces)
            {
                foreach (CodeNamespaceImport import in ns.Imports)
                {
                    list.Add(import);
                }
            }
            return list;
        }

        public virtual void GenerateIdentifier(string ident)
        {
            if (IsKeyword(ident))
            {
                ident = '@' + ident;
            }
            Output.Write(ident);
        }

        public virtual void GenerateTypeNamePair(CodeTypeReference typeRef, string name)
        {
            OutputType(typeRef);
            Output.Write(" ");
            GenerateIdentifier(name);
        }

        public virtual void GenerateParameterDeclarationExpression(CodeParameterDeclarationExpression e)
        {
            GenerateTypeNamePair(e.Type, e.Name);
        }

        public virtual void GenerateParameters(CodeExpressionCollection parameters)
        {
            for (int i = 0; i < parameters.Count; i++)
            {
                CodeExpression expression = parameters[i];
                GenerateExpression(expression);
                if (i != parameters.Count - 1)
                {
                    Output.Write(", ");
                }
            }
        }

        public virtual void GenerateParameters(CodeParameterDeclarationExpressionCollection parameters)
        {
            bool first = true;
            bool multiline = parameters.Count > 5;
            if (multiline)
            {
                Output.Indent += 3;
            }
            IEnumerator en = parameters.GetEnumerator();
            while (en.MoveNext())
            {
                CodeParameterDeclarationExpression current = (CodeParameterDeclarationExpression)en.Current;
                if (first)
                {
                    first = false;
                }
                else
                {
                    Output.Write(", ");
                }
                if (multiline)
                {
                    Output.WriteLine();
                }
                GenerateParameterDeclarationExpression(current);
            }
            if (multiline)
            {
                Output.Indent -= 3;
            }
        }
    }
}


